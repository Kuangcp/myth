package Rewrite;
/**
 * 测试继承里的方法重载问题
 * 多态
 * 以及父类子类的内存机制
 * <<多态>>：右边是编译时的状态 左边是运行时候的状态  （类型）father f2 = new son(" ");  弊端：只能使用父类的引用才能访问到父类的成员
 * 想要引用父类的（被隐藏/覆盖）成员：
 *           就只能通过父类的引用（创建也是父类自己的构造器），先用子类创建一个对象再强转成父类是没用的，调用的还是子类的
 *           若父类想调用自己的方法，但是子类中将这个方法重写了，那么这时候父类用的就是子类的那个方法不管是在 构造器还是普通方法里使用
 * 
 */
public class MainTest {
	public static void main(String [] args)throws Exception{
		son s = new son("son");
		father f = new father("father");
		
		f.show();//////////////////////本来就是父类的
		s.setMoney(90);
		s.show();/////////////////////本来就是子类的，毋庸置疑
		System.out.println("\nmoney="+s.money+" name="+s.name+" age="+((father)s).getAge());
		//这里的getAge方法，如果子类中没有这个方法，就会使用父类的，那么返回的也是父类的age,而不是子类的，虽然父类的本应该被覆盖了
		//    成员变量就可以这样强制类型转换 得到访问  方法却不行
		
		
		s.setName("father");
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		       //以下两种强制类型转换：
		System.out.println("\n想通过强制类型转换 通过字类对象来引用到 父类 的show方法");
		f=(father)s;     //子类转父类再 赋值给父类的引用
		f.show();          ///内存是子类的，show方法也是子类的 
		
		((father)s).show();/////
		
		// 也就是说子类的这个引用虽然强制类型转换成父类的，但是还是不能使用父类那个已经被覆盖的方法，即使父类的方法有内存空间
        // 但是成员变量却可以访问
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		                       //s=(son)f;       // 父类强制类型转换成子类  赋值给子类的引用  ！！！不可以，虽然能通过编译！！！
        System.out.println("name="+f.name+" age="+f.getAge());
                            //   "money="+f.money 这一段是报错的，因为是子类转成父类 money（子类中定义的）是不能被父类的引用来使用的
		
                          //     son s2 = new father();  报错：多态中 不能由父类转成子类
        
                   
//      多态：
      father f2 = new son("duo tai"); //子类可以转成父类  ，多态只能向上转型 父类的f2引用是没有money成员的
      
      System.out.println("\n通过多态来使用到 父类 的show方法");
      f2.show();//////////////////内存是子类的，show方法也是子类的 
      System.out.println("name="+f2.name+" age="+((father)f2).getAge());
      //这里的方法是用的父类的，因为多态，这个f2现在就是父类类型的引用变量 但是还是访问到子类的age
       
	}
}
